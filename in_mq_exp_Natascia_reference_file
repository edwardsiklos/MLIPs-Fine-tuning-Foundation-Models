log ${rundir}/lammps_logfile append

units metal
atom_style atomic

# --- read data or restart ---
if "${restart_from} == data" then "read_data ${data_file}"
if "${restart_from} == data" then "reset_timestep 0"
if "${restart_from} == continuation" then "read_restart ${rundir}/restart.*"

# --- potentials ---
mass 1 12.011
pair_style quip
pair_coeff * * ${pot} "" 6

neighbor 2.0 bin 
neigh_modify every 1 delay 0 check yes 

# --- thermodynamics ---
variable Nfreq equal 100
variable Nprint equal 100
variable Nevery equal 100
variable Nrepeat equal ${Nfreq}/${Nevery}
variable Ndump equal 100 
variable nAtoms equal atoms

group carbon type 1

timestep 0.001 # 1fs
variable dt equal 0.001

fix removeMomentum all momentum 1 linear 1 1 1 

compute T all temp 
fix TempAve all ave/time ${Nevery} ${Nrepeat} ${Nfreq} c_T 

variable P equal press 
fix PressAve all ave/time ${Nevery} ${Nrepeat} ${Nfreq} v_P 

variable v equal vol
fix vAve all ave/time ${Nevery} ${Nrepeat} ${Nfreq} v_v

compute PE all pe pair 
fix PEAve all ave/time ${Nevery} ${Nrepeat} ${Nfreq} c_PE
compute PEa all pe/atom pair

compute MSD all msd

thermo_style custom step cpu temp f_TempAve press f_PressAve f_PEAve vol f_vAve c_MSD[4] 
thermo_modify flush yes
thermo ${Nfreq}

# --- dump & restart ---
dump 1 all custom ${Ndump} ${rundir}/dump.dat id type x y z fx fy fz c_PEa
dump_modify 1 append yes

restart ${Ndump} ${rundir}/restart.last ${rundir}/restart.last

# --- define run steps ---
variable Nrun1 equal ${randomize_steps}
variable Nrun2 equal (${Nrun1}+${melt_steps})
variable Nrun3 equal (${Nrun2}+${quench_steps})
variable Nrun4 equal (${Nrun3}+${anneal_steps})

# --- initial velocity ---
if "${randomize_steps} > 0 && $(step) == 0" then "velocity all create ${t_randomize} ${rand}"

run 0

# --- randomize phase (Langevin + NVE) ---
fix integrator all nve
fix thermostat all langevin ${t_randomize} ${t_randomize} 0.1 ${rand}

if "$(step) < ${Nrun1}" then "run ${Nrun1} upto"
unfix thermostat
unfix integrator

# --- melt phase ---
fix integrator all nve
fix thermostat all langevin ${t_melt} ${t_melt} 0.1 ${rand}

if "$(step) < ${Nrun2}" then "run ${Nrun2} upto start ${Nrun1} stop ${Nrun2}"
unfix thermostat
unfix integrator

# --- exponential quench phase ---
variable Tmelt equal ${t_melt}
variable Tquench equal ${t_quench}
variable k equal 7
variable nsteps_quench equal ${quench_steps}
variable nchunks equal 5  # 500/5 = 100 steps per chunk to allow equilibration
variable chunk_size equal ${nsteps_quench}/${nchunks}
variable ichunk loop ${nchunks}

label quench_loop
variable frac equal (v_ichunk-1.0)/(v_nchunks-1.0)
variable Tcurrent equal v_Tquench+(v_Tmelt-v_Tquench)*exp(-v_k*v_frac)

fix integrator all nve
fix thermostat all langevin ${Tcurrent} ${Tcurrent} 0.01 ${rand} # tighter thermostat control for quench
run ${chunk_size}
unfix thermostat
unfix integrator

next ichunk
jump SELF quench_loop

# --- anneal phase ---
fix integrator all nve
fix thermostat all langevin ${t_quench} ${t_quench} 0.1 ${rand}

if "$(step) < ${Nrun4}" then "run ${Nrun4} upto start ${Nrun3} stop ${Nrun4}"
unfix thermostat
unfix integrator

# --- final output ---
write_data ${rundir}/out_data.dat
